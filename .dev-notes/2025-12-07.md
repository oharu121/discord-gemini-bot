# Dev Notes - 2025-12-07

## Summary

Modularized the monolithic `bot.py` into a proper Python package structure with separation of concerns. Added Router pattern to prepare for future AI-powered intent detection (function calling).

---

## Changes Made

### Before: Single File Structure

```
discord-bot/
├── bot.py              # Everything in one 227-line file
├── main.py             # Unused placeholder
├── pyproject.toml
└── .env
```

### After: Modular Package Structure

```
discord-bot/
├── src/
│   ├── __init__.py
│   ├── main.py              # Entry point
│   ├── config.py            # Environment + settings
│   │
│   ├── ai/
│   │   ├── __init__.py
│   │   ├── client.py        # GeminiClientWrapper
│   │   └── models.py        # Model name constants
│   │
│   ├── bot/
│   │   ├── __init__.py
│   │   ├── client.py        # DiscordBot class
│   │   └── handlers.py      # Router + message handlers
│   │
│   └── utils/
│       ├── __init__.py
│       └── logging.py       # Logger configuration
│
├── .dev-notes/
├── pyproject.toml           # Updated package config
└── .env
```

---

## File Breakdown

### src/config.py

- Loads environment variables (DISCORD_TOKEN, GOOGLE_API_KEY)
- Feature flag: `USE_FUNCTION_CALLING` (default: false)
- Validation function to check required config

### src/ai/models.py

- Model name constants extracted for easy updates:
  - `MODEL_TEXT = "gemini-3-pro-preview"`
  - `MODEL_IMAGE = "gemini-3-pro-image-preview"`
  - `MODEL_VIDEO = "veo-3.1-generate-preview"`

### src/ai/client.py

- `GeminiClientWrapper` class (extracted from bot.py lines 31-114)
- Methods: `generate_text()`, `generate_image()`, `generate_video()`
- Uses `asyncio.to_thread()` for non-blocking API calls

### src/bot/handlers.py

- **Router Pattern** for intent detection:
  - `Router` - Abstract base class
  - `KeywordRouter` - Current keyword matching (English only)
  - `FunctionCallingRouter` - Stub for AI-powered routing (TODO)
- Handler functions:
  - `handle_video_generation()`
  - `handle_image_generation()`
  - `handle_text_generation()`
- Main logic: `process_message()`

### src/bot/client.py

- `DiscordBot` class (extracted from bot.py lines 116-227)
- Selects router based on `USE_FUNCTION_CALLING` config
- Event handlers: `on_ready()`, `on_message()`

### src/main.py

- Clean entry point
- Validates config before starting
- Runs the bot

---

## Router Pattern Implementation

The key architectural addition for future scalability:

```python
# src/bot/handlers.py

class Router(ABC):
    @abstractmethod
    async def detect_intent(self, prompt: str) -> str:
        """Returns: 'text', 'image', or 'video'"""
        pass

class KeywordRouter(Router):
    """Current: keyword matching (English only)"""
    VIDEO_KEYWORDS = ["video of", "animate", "movie of", "generate a video"]
    IMAGE_KEYWORDS = ["image of", "draw", "paint", "generate an image", "picture of"]

    async def detect_intent(self, prompt: str) -> str:
        prompt_lower = prompt.lower()
        if any(kw in prompt_lower for kw in self.VIDEO_KEYWORDS):
            return "video"
        elif any(kw in prompt_lower for kw in self.IMAGE_KEYWORDS):
            return "image"
        return "text"

class FunctionCallingRouter(Router):
    """Future: AI-powered intent detection (all languages)"""
    def __init__(self, ai_client):
        self.ai = ai_client

    async def detect_intent(self, prompt: str) -> str:
        # TODO: Implement Gemini function calling
        raise NotImplementedError("Function calling not yet implemented")
```

### Router Selection (src/bot/client.py)

```python
if config.USE_FUNCTION_CALLING:
    self.router = FunctionCallingRouter(self.ai)
else:
    self.router = KeywordRouter()
```

---

## How to Run

```bash
# Option 1: Module execution
python -m src.main

# Option 2: Using uv with script entry point
uv run start
```

---

## pyproject.toml Updates

```toml
[tool.hatch.build.targets.wheel]
packages = ["src"]

[project.scripts]
start = "src.main:main"
```

---

## Future: Enable Function Calling

When ready to implement AI-powered intent detection:

1. Implement `FunctionCallingRouter.detect_intent()` in `src/bot/handlers.py`:

   - Define tools with descriptions for Gemini
   - Send prompt + tools to Gemini API
   - Parse function call response
   - Return intent string

2. Set environment variable:

   ```
   USE_FUNCTION_CALLING=true
   ```

3. Bot will automatically use AI to detect intent in any language

---

## Design Decisions

### Why This Structure (Not Over-Engineered)

| Decision              | Reasoning                                                      |
| --------------------- | -------------------------------------------------------------- |
| Single `handlers.py`  | 3 handlers are ~70 lines total. Separate files is overkill.    |
| No abstract AI client | Only one provider (Gemini). Add abstraction when needed.       |
| Router abstraction    | Will have 2 implementations soon (keyword vs function calling) |
| `src/` folder         | Standard Python packaging practice                             |
| Flat `utils/`         | Just logging for now. Grows naturally.                         |

### What We Avoided

- Over-engineering with factory patterns
- Dependency injection frameworks
- Too many tiny files
- Abstract base classes where not needed
- Premature optimization

---

## Files Deleted

- `bot.py` - Replaced by modular src/ structure
- `main.py` - Was unused placeholder from `uv init`

---

## Next Steps

1. **Implement FunctionCallingRouter** (Priority: High)

   - Use Gemini function calling API
   - Support all languages for intent detection

2. **Add Slash Commands** (Priority: Medium)

   - CommandTree is set up but no commands defined
   - Add /ask, /image, /video commands

3. **Add Tests** (Priority: Medium)
   - Create tests/ folder
   - Unit tests for routers and handlers

---

## References

- Previous notes: .dev-notes/2025-11-24.md
- Router pattern: src/bot/handlers.py
- Entry point: src/main.py
